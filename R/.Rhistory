ingreso_declarado, ingreso_verificado, cuota_ingreso,
capacidad_endeudamiento, endeudamiento_total, score_buro, tendencia_ingresos
)
# write.csv(financieras, "financieras_500.csv", row.names = FALSE)
# ================================
# Simulación: Post-desembolso (n=500)
# ================================
set.seed(777)
n <- 500
# --- Si NO existen variables financieras en el entorno, se simulan de forma coherente ---
if (!exists("ingreso_verificado")) {
ingreso_verificado <- round(pmin(pmax(rlnorm(n, log(2500), 0.55), 1200), 20000), 0)
}
if (!exists("cuota_ingreso")) {
cuota_ingreso <- pmin(0.55, pmax(0.05, rbeta(n, 2.5, 8)))  # DTI mensual
}
if (!exists("score_buro")) {
score_buro <- round(runif(n, 300, 950), 0)
}
# Cuota mensual estimada (monto de carga financiera mensual)
cuota_mensual <- cuota_ingreso * ingreso_verificado
# 1) Saldo promedio en cuenta (post-desembolso)
#    Promedio ~ 40% del ingreso verificado, con dispersión. Truncado a [0, 2*ingreso].
saldo_promedio <- rnorm(n, mean = 0.40 * ingreso_verificado, sd = 0.25 * ingreso_verificado)
saldo_promedio <- pmax(0, saldo_promedio)
saldo_promedio <- pmin(saldo_promedio, 2 * ingreso_verificado)
saldo_promedio <- round(saldo_promedio, 2)
# 2) Rebotes de débito automático
#    Aumentan cuando la cuota mensual supera al saldo promedio.
ratio <- cuota_mensual / pmax(saldo_promedio, 1)
ratio <- pmin(ratio, 5)                             # cota superior para estabilidad
lambda_reb <- pmin(4, pmax(0, 0.10 + 0.60 * ratio)) # tasa Poisson dependiente del estrés de pago
n_rebotes_debito <- pmin(rpois(n, lambda_reb), 6)
# 3) Accesos a canales digitales (actividad del cliente)
#    Base 4 accesos/mes + efecto de rebotes y DTI alto.
lambda_acc <- pmin(40, 4 + 2 * n_rebotes_debito + 3 * plogis((cuota_ingreso - 0.35) / 0.07))
accesos_digitales <- pmin(rpois(n, lambda_acc), 80)
# 4) Consultas sobre el préstamo (contactos/consultas registradas)
lambda_cons <- pmin(15, 0.8 + 0.9 * n_rebotes_debito + 3 * plogis((cuota_ingreso - 0.40) / 0.08))
consultas_credito <- pmin(rpois(n, lambda_cons), 30)
# 5) Tiempo de respuesta del cliente ante contacto (horas)
#    Base log-normal (~24h), más lento si hay rebotes; más rápido si el cliente es muy activo.
tiempo_base <- rlnorm(n, meanlog = log(24), sdlog = 0.6)
tiempo_respuesta <- tiempo_base * (1 + 0.20 * n_rebotes_debito) / (1 + 0.02 * accesos_digitales)
tiempo_respuesta <- round(pmin(168, pmax(1, tiempo_respuesta)), 1)  # 1h a 168h (1 semana)
# 6) Pago de la primera cuota (indicador binario)
#    Probabilidad ↑ con buen score y colchón (saldo >= cuota); ↓ con DTI alto y rebotes.
logit_p <- 2.3 - 3.2 * cuota_ingreso + (score_buro - 650) / 220 - 0.5 * n_rebotes_debito +
0.4 * as.numeric(saldo_promedio >= cuota_mensual)
prob_pago <- plogis(logit_p)
pago_primera_cuota <- rbinom(n, size = 1, prob = prob_pago)  # 1=pagó, 0=no pagó
# ================================
# Exportación individual a .txt (sin encabezado ni rownames)
# ================================
write.table(pago_primera_cuota, "pago_primera_cuota.txt", row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(saldo_promedio,     "saldo_promedio.txt",     row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(n_rebotes_debito,   "n_rebotes_debito.txt",   row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(accesos_digitales,  "accesos_digitales.txt",  row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(consultas_credito,  "consultas_credito.txt",  row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(tiempo_respuesta,   "tiempo_respuesta.txt",   row.names = FALSE, col.names = FALSE, quote = FALSE)
# =========================
# Simulación Financieras (n=500)
# =========================
set.seed(2025)
n <- 784
# 1) Ingreso declarado: sesgo a la derecha (log-normal)
ingreso_declarado <- rlnorm(n, meanlog = log(2500), sdlog = 0.55)
ingreso_declarado <- pmin(pmax(ingreso_declarado, 1200), 20000)
ingreso_declarado <- round(ingreso_declarado, 0)
# 2) Ingreso verificado: suele ser <= declarado, con ruido moderado
verif_factor <- pmin(pmax(rnorm(n, mean = 0.95, sd = 0.08), 0.70), 1.10)
ingreso_verificado <- round(ingreso_declarado * verif_factor, 0)
# 3) Tendencia de ingresos: crecimiento latente -> categorías
g <- rnorm(n, mean = 0, sd = 0.07)  # tasa mensual anualizada aproximada
tendencia_ingresos <- cut(
g,
breaks = c(-Inf, -0.03, 0.03, Inf),
labels = c("decreciente", "estable", "creciente")
)
# 4) Cuota/ingreso (DTI mensual): Beta con desplazamiento por tendencia
base_dti <- rbeta(n, shape1 = 2.5, shape2 = 8)  # ~0.24 en promedio
ajuste_tend <- ifelse(tendencia_ingresos == "decreciente", 0.05,
ifelse(tendencia_ingresos == "creciente", -0.03, 0))
cuota_ingreso <- pmin(0.55, pmax(0.05, base_dti + ajuste_tend))
# 5) Carga financiera mensual actual (monto)
endeudamiento_total <- round(cuota_ingreso * ingreso_verificado, 2)
# 6) Score buró: ↑ con ingreso, ↓ con DTI, penaliza tendencia negativa
z_ing  <- scale(log(pmax(ingreso_verificado, 1)))  # estabiliza varianza
z_dti  <- scale(cuota_ingreso)
bonus  <- ifelse(tendencia_ingresos == "creciente",  30,
ifelse(tendencia_ingresos == "decreciente", -50, 0))
score_raw <- 650 + 120 * as.numeric(z_ing) - 220 * as.numeric(z_dti) + bonus + rnorm(n, 0, 40)
score_buro <- round(pmin(950, pmax(300, score_raw)), 0)
# 7) Capacidad de endeudamiento (monto adicional de cuota posible)
#    Ratio máximo permitido depende del score (entre 20% y 50%)
ratio_max <- 0.35 + (score_buro - 650) / 300 * 0.10  # centra en 0.35
ratio_max <- pmin(0.50, pmax(0.20, ratio_max))
capacidad_endeudamiento <- (ratio_max - cuota_ingreso) * ingreso_verificado
capacidad_endeudamiento <- round(pmax(0, capacidad_endeudamiento), 2)
# =========================
# Exportes: uno por archivo .txt (sin loops)
# =========================
write.table(ingreso_declarado,         "ingreso_declarado.txt",         row.names=FALSE, col.names=FALSE, quote=FALSE)
write.table(ingreso_verificado,        "ingreso_verificado.txt",        row.names=FALSE, col.names=FALSE, quote=FALSE)
write.table(cuota_ingreso,             "cuota_ingreso.txt",             row.names=FALSE, col.names=FALSE, quote=FALSE)
write.table(capacidad_endeudamiento,   "capacidad_endeudamiento.txt",   row.names=FALSE, col.names=FALSE, quote=FALSE)
write.table(endeudamiento_total,       "endeudamiento_total.txt",       row.names=FALSE, col.names=FALSE, quote=FALSE)
write.table(score_buro,                "score_buro.txt",                row.names=FALSE, col.names=FALSE, quote=FALSE)
write.table(tendencia_ingresos,        "tendencia_ingresos.txt",        row.names=FALSE, col.names=FALSE, quote=FALSE)
# (Opcional) dataset completo para inspección rápida
financieras <- data.frame(
ingreso_declarado, ingreso_verificado, cuota_ingreso,
capacidad_endeudamiento, endeudamiento_total, score_buro, tendencia_ingresos
)
# write.csv(financieras, "financieras_500.csv", row.names = FALSE)
# ================================
# Simulación: Post-desembolso (n=500)
# ================================
set.seed(777)
n <- 500
# --- Si NO existen variables financieras en el entorno, se simulan de forma coherente ---
if (!exists("ingreso_verificado")) {
ingreso_verificado <- round(pmin(pmax(rlnorm(n, log(2500), 0.55), 1200), 20000), 0)
}
if (!exists("cuota_ingreso")) {
cuota_ingreso <- pmin(0.55, pmax(0.05, rbeta(n, 2.5, 8)))  # DTI mensual
}
if (!exists("score_buro")) {
score_buro <- round(runif(n, 300, 950), 0)
}
# Cuota mensual estimada (monto de carga financiera mensual)
cuota_mensual <- cuota_ingreso * ingreso_verificado
# 1) Saldo promedio en cuenta (post-desembolso)
#    Promedio ~ 40% del ingreso verificado, con dispersión. Truncado a [0, 2*ingreso].
saldo_promedio <- rnorm(n, mean = 0.40 * ingreso_verificado, sd = 0.25 * ingreso_verificado)
saldo_promedio <- pmax(0, saldo_promedio)
saldo_promedio <- pmin(saldo_promedio, 2 * ingreso_verificado)
saldo_promedio <- round(saldo_promedio, 2)
# 2) Rebotes de débito automático
#    Aumentan cuando la cuota mensual supera al saldo promedio.
ratio <- cuota_mensual / pmax(saldo_promedio, 1)
ratio <- pmin(ratio, 5)                             # cota superior para estabilidad
lambda_reb <- pmin(4, pmax(0, 0.10 + 0.60 * ratio)) # tasa Poisson dependiente del estrés de pago
n_rebotes_debito <- pmin(rpois(n, lambda_reb), 6)
# 3) Accesos a canales digitales (actividad del cliente)
#    Base 4 accesos/mes + efecto de rebotes y DTI alto.
lambda_acc <- pmin(40, 4 + 2 * n_rebotes_debito + 3 * plogis((cuota_ingreso - 0.35) / 0.07))
accesos_digitales <- pmin(rpois(n, lambda_acc), 80)
# 4) Consultas sobre el préstamo (contactos/consultas registradas)
lambda_cons <- pmin(15, 0.8 + 0.9 * n_rebotes_debito + 3 * plogis((cuota_ingreso - 0.40) / 0.08))
consultas_credito <- pmin(rpois(n, lambda_cons), 30)
# 5) Tiempo de respuesta del cliente ante contacto (horas)
#    Base log-normal (~24h), más lento si hay rebotes; más rápido si el cliente es muy activo.
tiempo_base <- rlnorm(n, meanlog = log(24), sdlog = 0.6)
tiempo_respuesta <- tiempo_base * (1 + 0.20 * n_rebotes_debito) / (1 + 0.02 * accesos_digitales)
tiempo_respuesta <- round(pmin(168, pmax(1, tiempo_respuesta)), 1)  # 1h a 168h (1 semana)
# 6) Pago de la primera cuota (indicador binario)
#    Probabilidad ↑ con buen score y colchón (saldo >= cuota); ↓ con DTI alto y rebotes.
logit_p <- 2.3 - 3.2 * cuota_ingreso + (score_buro - 650) / 220 - 0.5 * n_rebotes_debito +
0.4 * as.numeric(saldo_promedio >= cuota_mensual)
prob_pago <- plogis(logit_p)
pago_primera_cuota <- rbinom(n, size = 1, prob = prob_pago)  # 1=pagó, 0=no pagó
# ================================
# Exportación individual a .txt (sin encabezado ni rownames)
# ================================
write.table(pago_primera_cuota, "pago_primera_cuota.txt", row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(saldo_promedio,     "saldo_promedio.txt",     row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(n_rebotes_debito,   "n_rebotes_debito.txt",   row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(accesos_digitales,  "accesos_digitales.txt",  row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(consultas_credito,  "consultas_credito.txt",  row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(tiempo_respuesta,   "tiempo_respuesta.txt",   row.names = FALSE, col.names = FALSE, quote = FALSE)
# =========================
# Simulación Financieras (n=500)
# =========================
set.seed(2025)
n <- 191
# 1) Ingreso declarado: sesgo a la derecha (log-normal)
ingreso_declarado <- rlnorm(n, meanlog = log(2500), sdlog = 0.55)
ingreso_declarado <- pmin(pmax(ingreso_declarado, 1200), 20000)
ingreso_declarado <- round(ingreso_declarado, 0)
# 2) Ingreso verificado: suele ser <= declarado, con ruido moderado
verif_factor <- pmin(pmax(rnorm(n, mean = 0.95, sd = 0.08), 0.70), 1.10)
ingreso_verificado <- round(ingreso_declarado * verif_factor, 0)
# 3) Tendencia de ingresos: crecimiento latente -> categorías
g <- rnorm(n, mean = 0, sd = 0.07)  # tasa mensual anualizada aproximada
tendencia_ingresos <- cut(
g,
breaks = c(-Inf, -0.03, 0.03, Inf),
labels = c("decreciente", "estable", "creciente")
)
# 4) Cuota/ingreso (DTI mensual): Beta con desplazamiento por tendencia
base_dti <- rbeta(n, shape1 = 2.5, shape2 = 8)  # ~0.24 en promedio
ajuste_tend <- ifelse(tendencia_ingresos == "decreciente", 0.05,
ifelse(tendencia_ingresos == "creciente", -0.03, 0))
cuota_ingreso <- pmin(0.55, pmax(0.05, base_dti + ajuste_tend))
# 5) Carga financiera mensual actual (monto)
endeudamiento_total <- round(cuota_ingreso * ingreso_verificado, 2)
# 6) Score buró: ↑ con ingreso, ↓ con DTI, penaliza tendencia negativa
z_ing  <- scale(log(pmax(ingreso_verificado, 1)))  # estabiliza varianza
z_dti  <- scale(cuota_ingreso)
bonus  <- ifelse(tendencia_ingresos == "creciente",  30,
ifelse(tendencia_ingresos == "decreciente", -50, 0))
score_raw <- 650 + 120 * as.numeric(z_ing) - 220 * as.numeric(z_dti) + bonus + rnorm(n, 0, 40)
score_buro <- round(pmin(950, pmax(300, score_raw)), 0)
# 7) Capacidad de endeudamiento (monto adicional de cuota posible)
#    Ratio máximo permitido depende del score (entre 20% y 50%)
ratio_max <- 0.35 + (score_buro - 650) / 300 * 0.10  # centra en 0.35
ratio_max <- pmin(0.50, pmax(0.20, ratio_max))
capacidad_endeudamiento <- (ratio_max - cuota_ingreso) * ingreso_verificado
capacidad_endeudamiento <- round(pmax(0, capacidad_endeudamiento), 2)
# =========================
# Exportes: uno por archivo .txt (sin loops)
# =========================
write.table(ingreso_declarado,         "ingreso_declarado.txt",         row.names=FALSE, col.names=FALSE, quote=FALSE)
write.table(ingreso_verificado,        "ingreso_verificado.txt",        row.names=FALSE, col.names=FALSE, quote=FALSE)
write.table(cuota_ingreso,             "cuota_ingreso.txt",             row.names=FALSE, col.names=FALSE, quote=FALSE)
write.table(capacidad_endeudamiento,   "capacidad_endeudamiento.txt",   row.names=FALSE, col.names=FALSE, quote=FALSE)
write.table(endeudamiento_total,       "endeudamiento_total.txt",       row.names=FALSE, col.names=FALSE, quote=FALSE)
write.table(score_buro,                "score_buro.txt",                row.names=FALSE, col.names=FALSE, quote=FALSE)
write.table(tendencia_ingresos,        "tendencia_ingresos.txt",        row.names=FALSE, col.names=FALSE, quote=FALSE)
# (Opcional) dataset completo para inspección rápida
financieras <- data.frame(
ingreso_declarado, ingreso_verificado, cuota_ingreso,
capacidad_endeudamiento, endeudamiento_total, score_buro, tendencia_ingresos
)
# write.csv(financieras, "financieras_500.csv", row.names = FALSE)
# ================================
# Simulación: Post-desembolso (n=500)
# ================================
set.seed(777)
n <- 500
# --- Si NO existen variables financieras en el entorno, se simulan de forma coherente ---
if (!exists("ingreso_verificado")) {
ingreso_verificado <- round(pmin(pmax(rlnorm(n, log(2500), 0.55), 1200), 20000), 0)
}
if (!exists("cuota_ingreso")) {
cuota_ingreso <- pmin(0.55, pmax(0.05, rbeta(n, 2.5, 8)))  # DTI mensual
}
if (!exists("score_buro")) {
score_buro <- round(runif(n, 300, 950), 0)
}
# Cuota mensual estimada (monto de carga financiera mensual)
cuota_mensual <- cuota_ingreso * ingreso_verificado
# 1) Saldo promedio en cuenta (post-desembolso)
#    Promedio ~ 40% del ingreso verificado, con dispersión. Truncado a [0, 2*ingreso].
saldo_promedio <- rnorm(n, mean = 0.40 * ingreso_verificado, sd = 0.25 * ingreso_verificado)
saldo_promedio <- pmax(0, saldo_promedio)
saldo_promedio <- pmin(saldo_promedio, 2 * ingreso_verificado)
saldo_promedio <- round(saldo_promedio, 2)
# 2) Rebotes de débito automático
#    Aumentan cuando la cuota mensual supera al saldo promedio.
ratio <- cuota_mensual / pmax(saldo_promedio, 1)
ratio <- pmin(ratio, 5)                             # cota superior para estabilidad
lambda_reb <- pmin(4, pmax(0, 0.10 + 0.60 * ratio)) # tasa Poisson dependiente del estrés de pago
n_rebotes_debito <- pmin(rpois(n, lambda_reb), 6)
# 3) Accesos a canales digitales (actividad del cliente)
#    Base 4 accesos/mes + efecto de rebotes y DTI alto.
lambda_acc <- pmin(40, 4 + 2 * n_rebotes_debito + 3 * plogis((cuota_ingreso - 0.35) / 0.07))
accesos_digitales <- pmin(rpois(n, lambda_acc), 80)
# 4) Consultas sobre el préstamo (contactos/consultas registradas)
lambda_cons <- pmin(15, 0.8 + 0.9 * n_rebotes_debito + 3 * plogis((cuota_ingreso - 0.40) / 0.08))
consultas_credito <- pmin(rpois(n, lambda_cons), 30)
# 5) Tiempo de respuesta del cliente ante contacto (horas)
#    Base log-normal (~24h), más lento si hay rebotes; más rápido si el cliente es muy activo.
tiempo_base <- rlnorm(n, meanlog = log(24), sdlog = 0.6)
tiempo_respuesta <- tiempo_base * (1 + 0.20 * n_rebotes_debito) / (1 + 0.02 * accesos_digitales)
tiempo_respuesta <- round(pmin(168, pmax(1, tiempo_respuesta)), 1)  # 1h a 168h (1 semana)
# 6) Pago de la primera cuota (indicador binario)
#    Probabilidad ↑ con buen score y colchón (saldo >= cuota); ↓ con DTI alto y rebotes.
logit_p <- 2.3 - 3.2 * cuota_ingreso + (score_buro - 650) / 220 - 0.5 * n_rebotes_debito +
0.4 * as.numeric(saldo_promedio >= cuota_mensual)
prob_pago <- plogis(logit_p)
pago_primera_cuota <- rbinom(n, size = 1, prob = prob_pago)  # 1=pagó, 0=no pagó
# ================================
# Exportación individual a .txt (sin encabezado ni rownames)
# ================================
write.table(pago_primera_cuota, "pago_primera_cuota.txt", row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(saldo_promedio,     "saldo_promedio.txt",     row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(n_rebotes_debito,   "n_rebotes_debito.txt",   row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(accesos_digitales,  "accesos_digitales.txt",  row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(consultas_credito,  "consultas_credito.txt",  row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(tiempo_respuesta,   "tiempo_respuesta.txt",   row.names = FALSE, col.names = FALSE, quote = FALSE)
# ================================
# Simulación: Post-desembolso (n=500)
# ================================
set.seed(777)
n <- 433
# --- Si NO existen variables financieras en el entorno, se simulan de forma coherente ---
if (!exists("ingreso_verificado")) {
ingreso_verificado <- round(pmin(pmax(rlnorm(n, log(2500), 0.55), 1200), 20000), 0)
}
if (!exists("cuota_ingreso")) {
cuota_ingreso <- pmin(0.55, pmax(0.05, rbeta(n, 2.5, 8)))  # DTI mensual
}
if (!exists("score_buro")) {
score_buro <- round(runif(n, 300, 950), 0)
}
# Cuota mensual estimada (monto de carga financiera mensual)
cuota_mensual <- cuota_ingreso * ingreso_verificado
# 1) Saldo promedio en cuenta (post-desembolso)
#    Promedio ~ 40% del ingreso verificado, con dispersión. Truncado a [0, 2*ingreso].
saldo_promedio <- rnorm(n, mean = 0.40 * ingreso_verificado, sd = 0.25 * ingreso_verificado)
saldo_promedio <- pmax(0, saldo_promedio)
saldo_promedio <- pmin(saldo_promedio, 2 * ingreso_verificado)
saldo_promedio <- round(saldo_promedio, 2)
# 2) Rebotes de débito automático
#    Aumentan cuando la cuota mensual supera al saldo promedio.
ratio <- cuota_mensual / pmax(saldo_promedio, 1)
ratio <- pmin(ratio, 5)                             # cota superior para estabilidad
lambda_reb <- pmin(4, pmax(0, 0.10 + 0.60 * ratio)) # tasa Poisson dependiente del estrés de pago
n_rebotes_debito <- pmin(rpois(n, lambda_reb), 6)
# 3) Accesos a canales digitales (actividad del cliente)
#    Base 4 accesos/mes + efecto de rebotes y DTI alto.
lambda_acc <- pmin(40, 4 + 2 * n_rebotes_debito + 3 * plogis((cuota_ingreso - 0.35) / 0.07))
accesos_digitales <- pmin(rpois(n, lambda_acc), 80)
# 4) Consultas sobre el préstamo (contactos/consultas registradas)
lambda_cons <- pmin(15, 0.8 + 0.9 * n_rebotes_debito + 3 * plogis((cuota_ingreso - 0.40) / 0.08))
consultas_credito <- pmin(rpois(n, lambda_cons), 30)
# 5) Tiempo de respuesta del cliente ante contacto (horas)
#    Base log-normal (~24h), más lento si hay rebotes; más rápido si el cliente es muy activo.
tiempo_base <- rlnorm(n, meanlog = log(24), sdlog = 0.6)
tiempo_respuesta <- tiempo_base * (1 + 0.20 * n_rebotes_debito) / (1 + 0.02 * accesos_digitales)
tiempo_respuesta <- round(pmin(168, pmax(1, tiempo_respuesta)), 1)  # 1h a 168h (1 semana)
# 6) Pago de la primera cuota (indicador binario)
#    Probabilidad ↑ con buen score y colchón (saldo >= cuota); ↓ con DTI alto y rebotes.
logit_p <- 2.3 - 3.2 * cuota_ingreso + (score_buro - 650) / 220 - 0.5 * n_rebotes_debito +
0.4 * as.numeric(saldo_promedio >= cuota_mensual)
prob_pago <- plogis(logit_p)
pago_primera_cuota <- rbinom(n, size = 1, prob = prob_pago)  # 1=pagó, 0=no pagó
# ================================
# Exportación individual a .txt (sin encabezado ni rownames)
# ================================
write.table(pago_primera_cuota, "pago_primera_cuota.txt", row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(saldo_promedio,     "saldo_promedio.txt",     row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(n_rebotes_debito,   "n_rebotes_debito.txt",   row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(accesos_digitales,  "accesos_digitales.txt",  row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(consultas_credito,  "consultas_credito.txt",  row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(tiempo_respuesta,   "tiempo_respuesta.txt",   row.names = FALSE, col.names = FALSE, quote = FALSE)
logit_p
table(cancelaciones_anticipadas)
table(accesos_digitales)
table(consultas_credito)
table(rfm)
# ================================
# Simulación: Post-desembolso (n=500)
# ================================
set.seed(777)
n <- 1000
# --- Si NO existen variables financieras en el entorno, se simulan de forma coherente ---
if (!exists("ingreso_verificado")) {
ingreso_verificado <- round(pmin(pmax(rlnorm(n, log(2500), 0.55), 1200), 20000), 0)
}
if (!exists("cuota_ingreso")) {
cuota_ingreso <- pmin(0.55, pmax(0.05, rbeta(n, 2.5, 8)))  # DTI mensual
}
if (!exists("score_buro")) {
score_buro <- round(runif(n, 300, 950), 0)
}
# Cuota mensual estimada (monto de carga financiera mensual)
cuota_mensual <- cuota_ingreso * ingreso_verificado
# 1) Saldo promedio en cuenta (post-desembolso)
#    Promedio ~ 40% del ingreso verificado, con dispersión. Truncado a [0, 2*ingreso].
saldo_promedio <- rnorm(n, mean = 0.40 * ingreso_verificado, sd = 0.25 * ingreso_verificado)
saldo_promedio <- pmax(0, saldo_promedio)
saldo_promedio <- pmin(saldo_promedio, 2 * ingreso_verificado)
saldo_promedio <- round(saldo_promedio, 2)
# 2) Rebotes de débito automático
#    Aumentan cuando la cuota mensual supera al saldo promedio.
ratio <- cuota_mensual / pmax(saldo_promedio, 1)
ratio <- pmin(ratio, 5)                             # cota superior para estabilidad
lambda_reb <- pmin(4, pmax(0, 0.10 + 0.60 * ratio)) # tasa Poisson dependiente del estrés de pago
n_rebotes_debito <- pmin(rpois(n, lambda_reb), 6)
# 3) Accesos a canales digitales (actividad del cliente)
#    Base 4 accesos/mes + efecto de rebotes y DTI alto.
lambda_acc <- pmin(40, 4 + 2 * n_rebotes_debito + 3 * plogis((cuota_ingreso - 0.35) / 0.07))
accesos_digitales <- pmin(rpois(n, lambda_acc), 80)
# 4) Consultas sobre el préstamo (contactos/consultas registradas)
lambda_cons <- pmin(15, 0.8 + 0.9 * n_rebotes_debito + 3 * plogis((cuota_ingreso - 0.40) / 0.08))
consultas_credito <- pmin(rpois(n, lambda_cons), 30)
# 5) Tiempo de respuesta del cliente ante contacto (horas)
#    Base log-normal (~24h), más lento si hay rebotes; más rápido si el cliente es muy activo.
tiempo_base <- rlnorm(n, meanlog = log(24), sdlog = 0.6)
tiempo_respuesta <- tiempo_base * (1 + 0.20 * n_rebotes_debito) / (1 + 0.02 * accesos_digitales)
tiempo_respuesta <- round(pmin(168, pmax(1, tiempo_respuesta)), 1)  # 1h a 168h (1 semana)
# 6) Pago de la primera cuota (indicador binario)
#    Probabilidad ↑ con buen score y colchón (saldo >= cuota); ↓ con DTI alto y rebotes.
logit_p <- 2.3 - 3.2 * cuota_ingreso + (score_buro - 650) / 220 - 0.5 * n_rebotes_debito +
0.4 * as.numeric(saldo_promedio >= cuota_mensual)
prob_pago <- plogis(logit_p)
pago_primera_cuota <- rbinom(n, size = 1, prob = prob_pago)  # 1=pagó, 0=no pagó
# ================================
# Exportación individual a .txt (sin encabezado ni rownames)
# ================================
write.table(pago_primera_cuota, "pago_primera_cuota.txt", row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(saldo_promedio,     "saldo_promedio.txt",     row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(n_rebotes_debito,   "n_rebotes_debito.txt",   row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(accesos_digitales,  "accesos_digitales.txt",  row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(consultas_credito,  "consultas_credito.txt",  row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(tiempo_respuesta,   "tiempo_respuesta.txt",   row.names = FALSE, col.names = FALSE, quote = FALSE)
table(cancelaciones_anticipadas)
table(accesos_digitales)
table(consultas_credito)
table(rfm)
# ---------------------------
# Simulación: Comportamiento histórico (n = 500)
# ---------------------------
set.seed(123)
n <- 1000
# 1) Antigüedad del cliente (meses)
#    Perfil sesgado a la derecha (más clientes "jóvenes" en el banco), tope 240 meses
antiguedad_cliente <- pmin(round(rlnorm(n, meanlog = log(48), sdlog = 0.6)), 240)
# 2) Moras previas (conteos, con muchos ceros)  -> Zero-Inflated Poisson
zi_previas <- rbinom(n, 1, 0.70)                    # 70% con 0 moras históricas
n_moras_previas <- ifelse(zi_previas == 1, 0, rpois(n, lambda = 0.8))
n_moras_previas <- pmin(n_moras_previas, 10)
# 3) Días de atraso máximo (0 si no hay moras; sesgo a derecha si >0)
#    Usamos NB para cola más larga y truncamos en 120 días
dias_atraso_raw <- rnbinom(n, size = 2, mu = 20)
dias_atraso_max <- ifelse(n_moras_previas == 0, 0, pmin(dias_atraso_raw, 120))
# 4) Frecuencia de moras leves (1–15 días) — mayor si hubo moras previas
lambda_leves <- ifelse(n_moras_previas > 0, 1.5, 0.3)
n_moras_leves <- pmin(rpois(n, lambda = lambda_leves), 12)
# 5) Productos activos (0–6) — discreto con probabilidades realistas
productos_activos <- sample(0:6, size = n, replace = TRUE,
prob = c(0.10, 0.25, 0.30, 0.20, 0.10, 0.04, 0.01))
# 6) Frecuencia de uso (transacciones/mes) — Poisson dependiente de productos
#    Base de 2 transacciones/mes + 1.5 por cada producto activo
lambda_tx <- pmax(0.5, 2 + 1.5 * productos_activos)
frecuencia_uso <- pmin(rpois(n, lambda = lambda_tx), 80)
# 7) Cancelaciones anticipadas (conteo bajo), algo mayor si tiene muchos productos
lambda_cancel <- ifelse(productos_activos >= 3, 0.5, 0.2)
cancelaciones_anticipadas <- pmin(rpois(n, lambda = lambda_cancel), 6)
# 8) RFM (único indicador cuantitativo 0–100)
#    Simulamos componentes y los combinamos en un score:
#    - Recency (días desde última transacción): exp( media ~60 días ), menor es mejor
#    - Frequency: reutilizamos frecuencia_uso (mayor es mejor)
#    - Monetary (monto promedio de operación): lognormal (mediana ~150)
recency <- pmin(pmax(round(rexp(n, rate = 1/60)), 1), 365)
monetary <- pmin(round(rlnorm(n, meanlog = log(150), sdlog = 0.7), 2), 3000)
# Escoramos en quintiles (1–5) e invertimos Recency
cuts_r <- quantile(recency, probs = seq(0, 1, 0.2), na.rm = TRUE)
cuts_f <- quantile(frecuencia_uso, probs = seq(0, 1, 0.2), na.rm = TRUE)
cuts_m <- quantile(monetary, probs = seq(0, 1, 0.2), na.rm = TRUE)
r_score <- as.integer(cut(recency, breaks = cuts_r, include.lowest = TRUE, labels = 5:1))
f_score <- as.integer(cut(frecuencia_uso, breaks = cuts_f, include.lowest = TRUE, labels = 1:5))
m_score <- as.integer(cut(monetary, breaks = cuts_m, include.lowest = TRUE, labels = 1:5))
# RFM normalizado a 0–100
rfm <- round((r_score + f_score + m_score) / 15 * 100, 0)
# ---------------------------
# Exportación: un TXT por variable (sin encabezados, sin rownames)
# ---------------------------
write.table(antiguedad_cliente,      "antiguedad_cliente.txt",      row.names = FALSE, col.names = FALSE)
write.table(n_moras_previas,         "n_moras_previas.txt",         row.names = FALSE, col.names = FALSE)
write.table(dias_atraso_max,         "dias_atraso_max.txt",         row.names = FALSE, col.names = FALSE)
write.table(n_moras_leves,           "n_moras_leves.txt",           row.names = FALSE, col.names = FALSE)
write.table(productos_activos,       "productos_activos.txt",       row.names = FALSE, col.names = FALSE)
write.table(frecuencia_uso,          "frecuencia_uso.txt",          row.names = FALSE, col.names = FALSE)
write.table(cancelaciones_anticipadas,"cancelaciones_anticipadas.txt",row.names = FALSE, col.names = FALSE)
write.table(rfm,                     "rfm.txt",                     row.names = FALSE, col.names = FALSE)
shiny::runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
runApp('~/Documentos TESIS/Proyecto-Modulos/app')
